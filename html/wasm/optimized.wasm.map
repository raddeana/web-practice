{"version":3,"sources":["~lib/rt/common.ts","assembly/mandelbrot.ts"],"names":[],"mappings":"wGCUE,AAAiB,AAAC,GAAI,AAFL,GAAU,WAES,AADnB,SAAO,AAAI,AAAI,EAAJ,KAAW,AAAI,EAAJ,kBAEvC,AAAiB,AAJA,GAAU,UAIG,KAC9B,AAAiB,AAAC,EAAI,GAAU,KAChC,AAAiB,SAAM,MAEvB,AAAoB,EAAO,UAEtB,AAAa,MAAG,AAAI,EAAJ,KACnB,AAAW,GAAI,GAAQ,KAGd,sBACT,AAAqB,MACd,AAAC,AAAO,EAAK,KAAO,AAAO,EAAK,MAAO,YAA9C,EACE,AAAK,AAAM,KAAK,GAAK,KACrB,AAAK,EAAO,GAAO,KACnB,AAAI,AAAa,EAAb,KAEJ,YAIF,EAAO,AAAY,EAAZ,KACL,AAAY,EAAK,GAAK,EAAK,IAAK,KAChC,AAAK,AAAM,KAAK,GAAK,KACrB,AAAK,IACL,AAAE,WAYJ,AAAW,EAAU,EAAK,IAJtB,AADM,EAAK,GAAK,EAAK,MACf,YAEF,AAAyB,AASxB,AAAI,AATgC,EAAY,IAAI,AADtC,AAAM,AAAS,IAAf,aAC8C,GASjD,UAAW,6BAtCD,AAAE","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","// see: https://en.wikipedia.org/wiki/Mandelbrot_set\r\n\r\n/** Number of discrete color values on the JS side. */\r\nconst NUM_COLORS = 2048;\r\n\r\n/** Computes a single line in the rectangle `width` x `height`. */\r\nexport function computeLine(y: u32, width: u32, height: u32, limit: u32): void {\r\n  var translateX = width  * (1.0 / 1.6);\r\n  var translateY = height * (1.0 / 2.0);\r\n  var scale      = 10.0 / min(3 * width, 4 * height);\r\n  var imaginary  = (y - translateY) * scale;\r\n  var realOffset = translateX * scale;\r\n  var stride     = (y * width) << 1;\r\n  var invLimit   = 1.0 / limit;\r\n\r\n  var minIterations = min(8, limit);\r\n\r\n  for (let x: u32 = 0; x < width; ++x) {\r\n    let real = x * scale - realOffset;\r\n\r\n    // Iterate until either the escape radius or iteration limit is exceeded\r\n    let ix = 0.0, iy = 0.0, ixSq: f64, iySq: f64;\r\n    let iteration: u32 = 0;\r\n    while ((ixSq = ix * ix) + (iySq = iy * iy) <= 4.0) {\r\n      iy = 2.0 * ix * iy + imaginary;\r\n      ix = ixSq - iySq + real;\r\n      if (iteration >= limit)\r\n        break;\r\n      iteration ++;\r\n    }\r\n\r\n    // Do a few extra iterations for quick escapes to reduce error margin\r\n    while (iteration < minIterations) {\r\n      let ixNew = ix * ix - iy * iy + real;\r\n      iy = 2.0 * ix * iy + imaginary;\r\n      ix = ixNew;\r\n      ++iteration;\r\n    }\r\n\r\n    // Iteration count is a discrete value in the range [0, limit] here, but we'd like it to be\r\n    // normalized in the range [0, 2047] so it maps to the gradient computed in JS.\r\n    // see also: http://linas.org/art-gallery/escape/escape.html\r\n    let col = NUM_COLORS - 1;\r\n    let sqd = ix * ix + iy * iy;\r\n    if (sqd > 1.0) {\r\n      let frac = Math.log2(0.5 * Math.log(sqd));\r\n      col = <u32>((NUM_COLORS - 1) * clamp<f64>((iteration + 1 - frac) * invLimit, 0.0, 1.0));\r\n    }\r\n    store<u16>(stride + (x << 1), col);\r\n  }\r\n}\r\n\r\n/** Clamps a value between the given minimum and maximum. */\r\n@inline\r\nfunction clamp<T>(value: T, minValue: T, maxValue: T): T {\r\n  return min(max(value, minValue), maxValue);\r\n}\r\n"]}